// On ne met pas de plugins, ils sont gérés par le fichier racine

base {
    // ESSENTIEL : On définit le nom spécifique ici pour ne pas écraser les autres mods
    archivesName = "piggy-inventory"
}

loom {
    // Vous aviez cette config spécifique, on la garde
    splitEnvironmentSourceSets()

    mods {
        "piggy-inventory" {
            sourceSet sourceSets.main
            sourceSet sourceSets.client
        }
    }
}

// Configuration du DataGen spécifique à ce mod
fabricApi {
    configureDataGeneration {
        client = true
    }
}

dependencies {
    // Note : Minecraft, Mappings (Yarn), Loader et Fabric API sont hérités du fichier racine.
    
    // Vos dépendances spécifiques (YACL et ModMenu)
    modImplementation "dev.isxander:yet-another-config-lib:${project.yacl_version}"
    modImplementation "com.terraformersmc:modmenu:${project.modmenu_version}"
    
    // --- LIAISON AVEC PIGGY LIB ---
    
    // On utilise 'implementation' pour compiler avec les sources de la lib
    // Use sourceSets output directly to bypass jar artifact issues
    implementation project(':piggy-lib').sourceSets.main.output
    clientImplementation project(':piggy-lib').sourceSets.main.output
    
    // Si vous voulez que la lib soit incluse dans le jar final de l'inventaire (Fat Jar) :
    include project(':piggy-lib')
}

// Force classpath injection using file path to guarantee visibility
// Wrapped in afterEvaluate to ensure it persists after Loom configuration
afterEvaluate {
    tasks.named('compileClientJava').configure {
        def libProject = project(':piggy-lib')
        def libClassesDirs = libProject.sourceSets.main.output.classesDirs
        
        // Add classes to classpath
        classpath += libClassesDirs
        
        doFirst {
            println "=== CI DEBUG START: compileClientJava ==="
            println "Task Classpath:"
            classpath.each { println "  - ${it}" }
            
            println "\nChecking piggy-lib classes..."
            libClassesDirs.each { dir ->
                println "Dir: ${dir}"
                println "Exists: ${dir.exists()}"
                if (dir.exists()) {
                    println "Contents:"
                    fileTree(dir).visit { details ->
                        println "  > ${details.relativePath}"
                    }
                } else {
                    println "  ! Directory does not exist !"
                }
            }
            println "=== CI DEBUG END ==="
        }
    }
}